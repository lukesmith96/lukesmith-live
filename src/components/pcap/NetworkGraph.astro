---
/**
 * Network Graph Visualization Component using D3.js
 * Pure Astro component with vanilla JavaScript and D3
 */
---

<div id="networkGraphContainer" class="hidden mt-8 pt-8 border-t border-skin-muted/20">
  <h3 class="text-2xl font-bold text-skin-base mb-4">Network Graph</h3>

  <div class="flex flex-wrap gap-4 mb-4">
    <div class="flex items-center gap-2">
      <span class="w-3 h-3 rounded-full bg-red-500"></span>
      <span class="text-sm text-skin-base">Attacker</span>
    </div>
    <div class="flex items-center gap-2">
      <span class="w-3 h-3 rounded-full bg-orange-500"></span>
      <span class="text-sm text-skin-base">Compromised</span>
    </div>
    <div class="flex items-center gap-2">
      <span class="w-3 h-3 rounded-full" style="background-color: #667eea;"></span>
      <span class="text-sm text-skin-base">Victim</span>
    </div>
    <div class="flex items-center gap-2">
      <span class="w-3 h-3 rounded-full bg-skin-muted/40"></span>
      <span class="text-sm text-skin-base">External</span>
    </div>
  </div>

  <svg id="networkGraph" class="w-full bg-skin-fill/70 rounded-lg" width="600" height="400"></svg>
</div>

<div id="networkGraphEmpty" class="mt-8 pt-8 border-t border-skin-muted/20">
  <h3 class="text-2xl font-bold text-skin-base mb-4">Network Graph</h3>
  <div class="bg-skin-fill/70 rounded-lg p-12 text-center border-2 border-dashed border-skin-muted/30">
    <p class="text-skin-muted">No network connections to visualize</p>
  </div>
</div>

<script>
  // D3 is loaded globally from CDN in the page head
  declare const d3: any;

  interface Node {
    id: string;
    type: 'attacker' | 'compromised' | 'victim' | 'external';
    threats: number;
    x?: number;
    y?: number;
    fx?: number | null;
    fy?: number | null;
  }

  interface Link {
    source: string | Node;
    target: string | Node;
    threat: string;
    severity: string;
  }

  function renderGraph(threats: any[]) {
    const container = document.getElementById('networkGraphContainer');
    const emptyState = document.getElementById('networkGraphEmpty');
    const svg = document.getElementById('networkGraph');

    if (!threats || threats.length === 0) {
      container?.classList.add('hidden');
      emptyState?.classList.remove('hidden');
      return;
    }

    container?.classList.remove('hidden');
    emptyState?.classList.add('hidden');

    // Clear previous graph
    d3.select(svg).selectAll('*').remove();

    // Extract nodes and links from threats
    const nodes = new Map<string, Node>();
    const links: Link[] = [];

    threats.forEach((threat: any) => {
      const sourceIp = threat.source_ip || threat.compromised_host || 'Unknown';
      const targetIp = threat.target_ip || threat.destination_ip || threat.c2_server || 'Multiple';

      // Add nodes
      if (!nodes.has(sourceIp)) {
        nodes.set(sourceIp, {
          id: sourceIp,
          type: threat.source_ip ? 'attacker' : 'compromised',
          threats: 1,
        });
      } else {
        nodes.get(sourceIp)!.threats++;
      }

      if (!nodes.has(targetIp)) {
        nodes.set(targetIp, {
          id: targetIp,
          type: threat.target_ip ? 'victim' : 'external',
          threats: 1,
        });
      } else {
        nodes.get(targetIp)!.threats++;
      }

      // Add link
      if (sourceIp !== targetIp) {
        links.push({
          source: sourceIp,
          target: targetIp,
          threat: threat.type,
          severity: threat.severity,
        });
      }
    });

    const nodesArray = Array.from(nodes.values());

    // Set up SVG
    const width = 600;
    const height = 400;
    const svgEl = d3
      .select(svg)
      .attr('width', width)
      .attr('height', height)
      .attr('viewBox', `0 0 ${width} ${height}`);

    // Create force simulation
    const simulation = d3
      .forceSimulation(nodesArray)
      .force(
        'link',
        d3
          .forceLink(links)
          .id((d: any) => d.id)
          .distance(150)
      )
      .force('charge', d3.forceManyBody().strength(-400))
      .force('center', d3.forceCenter(width / 2, height / 2))
      .force('collision', d3.forceCollide().radius(40));

    // Color scale for severity
    const severityColor: Record<string, string> = {
      critical: '#ef4444',
      high: '#f97316',
      medium: '#eab308',
      low: '#22c55e',
    };

    // Draw links
    const link = svgEl
      .append('g')
      .selectAll('line')
      .data(links)
      .join('line')
      .attr('stroke', (d: any) => severityColor[d.severity] || '#999')
      .attr('stroke-width', 2)
      .attr('stroke-opacity', 0.6)
      .attr('marker-end', 'url(#arrowhead)');

    // Add arrowhead marker
    svgEl
      .append('defs')
      .append('marker')
      .attr('id', 'arrowhead')
      .attr('viewBox', '-0 -5 10 10')
      .attr('refX', 25)
      .attr('refY', 0)
      .attr('orient', 'auto')
      .attr('markerWidth', 6)
      .attr('markerHeight', 6)
      .append('svg:path')
      .attr('d', 'M 0,-5 L 10,0 L 0,5')
      .attr('fill', '#999');

    // Node color by type
    const nodeColor: Record<string, string> = {
      attacker: '#ef4444',
      compromised: '#f97316',
      victim: '#667eea',
      external: '#6c757d',
    };

    // Draw nodes
    const node = svgEl
      .append('g')
      .selectAll('circle')
      .data(nodesArray)
      .join('circle')
      .attr('r', (d: any) => 15 + d.threats * 3)
      .attr('fill', (d: any) => nodeColor[d.type] || '#667eea')
      .attr('stroke', '#fff')
      .attr('stroke-width', 2)
      .call(
        d3
          .drag()
          .on('start', dragstarted)
          .on('drag', dragged)
          .on('end', dragended)
      );

    // Add labels
    const label = svgEl
      .append('g')
      .selectAll('text')
      .data(nodesArray)
      .join('text')
      .text((d: any) => d.id)
      .attr('font-size', 11)
      .attr('font-weight', 'bold')
      .attr('fill', 'currentColor')
      .attr('text-anchor', 'middle')
      .attr('dy', -25);

    // Add tooltips
    node.append('title').text((d: any) => `${d.id}\nType: ${d.type}\nThreats: ${d.threats}`);

    // Update positions on tick
    simulation.on('tick', () => {
      link
        .attr('x1', (d: any) => d.source.x)
        .attr('y1', (d: any) => d.source.y)
        .attr('x2', (d: any) => d.target.x)
        .attr('y2', (d: any) => d.target.y);

      node.attr('cx', (d: any) => d.x).attr('cy', (d: any) => d.y);

      label.attr('x', (d: any) => d.x).attr('y', (d: any) => d.y);
    });

    // Drag functionality
    function dragstarted(event: any) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      event.subject.fx = event.subject.x;
      event.subject.fy = event.subject.y;
    }

    function dragged(event: any) {
      event.subject.fx = event.x;
      event.subject.fy = event.y;
    }

    function dragended(event: any) {
      if (!event.active) simulation.alphaTarget(0);
      event.subject.fx = null;
      event.subject.fy = null;
    }
  }

  // Listen for graph update events
  window.addEventListener('update-network-graph', ((e: CustomEvent) => {
    renderGraph(e.detail);
  }) as EventListener);
</script>
